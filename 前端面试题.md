### Vue阶段面试题

### 1.你怎么理解指令？工作中你封装过自定义指令吗？举一些例子

```
指令是带有v-前缀的特殊attribute，指令的职责是，当表达式的值发生改变时，将其产生的连带影响，响应式地作用于DOM。
在项目中有一些常用的DOM功能要复用时，就可以封装成指令，这就是自定义指令。自定义指令分为全局指令和局部指令。
全局指令：使用 Vue.directive('指令名', fn/{})定义全局指令，在任何组件中都能使用。
局部指令：使用 directives: {} 定义局部指令，只能在当前组件中使用。

我封装过的自定义指令，比如：

权限指令:就是定义权限，先创建一个权限库，里面放着有访问权限的用户名称，当用户访问权限按钮的时候，会去校验用户名称是否在权限库，如果在，才可以点击按钮提交，否则按钮是不生效的。

拖拽指令:给某个元素加上拖拽指令，点击元素并按住鼠标拖拽，可以实现元素跟随鼠标移动到鼠标松开的位置。
```



### 2.计算属性能不能绑定在v-model上？

```
使用v-model绑定计算属性；需要定义完整结构的计算属性，即get和set都要设置，修改计算属性的值，通过走set来实现
```



### 3.侦听器能监听哪些变量变化？

```
可以监听 字符串、数字、数组，对象，

如果侦听的是数组，只能侦听到标准方法修改数组，也就是push pop unshift shift splice sort reverse

如果监听的是对象，那对象的属性值变化时，无法被侦听到，需要使用deep，可以实现深度侦听
```



### 4.**说一下Vue的响应式原理？(你是如何理解MVVM的)**



```
Vue 的响应式是通过 Object.defineProperty 对数据进行劫持，并结合发布订阅者模式实现。 Vue 利用 Object.defineProperty 创建一个 observe 来劫持监听所有的属性，把这些属性全部转为 getter 和 setter。Vue 中每个组件实例都会对应一个 watcher 实例，它会在组件渲染的过程中把使用过的数据属性通过 getter 收集为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。
```




### 5.你工作中有没有封装比较好的组件？

```
封装过按钮组件，类似于elementUI里面的按钮，只需要把文件引入到项目中，就可以用设定好的自定义组件添加到页面上，给自定义组件上添加自定义属性，就可以修改按钮的颜色、样式、大小、弧度等，增加了开发的效率。


```



### 6.说一下Vue的生命周期（展开说，不仅仅是那几个钩子）？

**创建：**

```text
beforeCreate():

​在组件实例初始化完成之后就立即调用，如果使用组合式写法，setup（）钩子会在所有选项式API之前调用，包括beforeCreate()
```

```text
created():

​执行这个函数的时候，vue实例已经初始化，会设置响应式数据，计算属性，方法和侦听器,data可以访问

​常用于自动ajax请求，事件监听，定时器开启等等

​此时挂载尚未完成，$el仍不可用
```

**挂载：**

```text
beforeMount():

​当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程
```

```text
mounted():

​挂载所有同步子组件,不包括异步组件,

​dom树已经渲染到页面，可以进行dom操作
```

**更新**：

```text
beforeUpdate():

​vue 已经将模板字符串编译成内存虚拟DOM，模板已经编译完成，已经完成渲染树，还没有渲染到页面上。可以获取初始数据，实现函数自执行。
```

```text
updated():

​updated会因为一个响应式状态变更而更新DOM树之后调用

​父组件的更新钩子会在其子组件的更新钩子之后调用.

​updated会在任意组件的任意DOM更新之后被调用

​这个钩子在服务端渲染时不会被调用。

​不要在 updated 钩子中更改组件的状态，这可能会导致无限的更新循环！
```

​		

**销毁:**

```text
beforeDestroy()

​此时刚刚脱离运行阶段，data、methods，指令之类的都在正常运行,用于清空定时器，解除事件绑定，清除缓存等,
```

```text
destroyed()
​组件销毁完毕，data，methods，指令之类的不可用
```



### 7.虚拟DOM存在的价值点在哪里？

```
避免直接操作DOM，提高开发效率

复杂视图情况下提升渲染性能，如果有频繁DOM操作的话，虚拟DOM在更新真实DOM之前，首先会通过Diff算法对比新旧两个DOM树的差异，最终把差异更新到真实DOM上，不会每次操作真实DOM，另外通过给节点设置Key属性，可以让节点重用，避免大量的重绘，可以提升性能
```



### 8.Vue有哪些内置组件？Vue中实现条件渲染渲染有哪些办法？

```
vue的内置组件: component 动态组件 transition 动画 transition-group 动画 keep-alive 缓存 slot 插槽

实现条件渲染：v-show/v-if,<component>、路由或嵌套路由
```



### 9.你有封装过Vue插件？怎么封装的？封装过什么？

```
有，封装了常用按钮的样式和用法，

类似于elementUI里面的按钮，只需要把文件引入到项目中，就可以用设定好的自定义组件添加到页面上，给自定义组件上添加自定义属性，就可以修改按钮的颜色、样式、大小、弧度等，增加了开发的效率

一般会把老项目中封装的好用东西，以插件的方式搬到新项目中去
```



### 10.谈一谈你对 Vue.nextTick() 的理解？有什么用？

```
在更新队列中每一个更新任务都是一个更新单元，nextTick表示下一个更新单元（更新周期）。
作用：
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用Vue.nextTick() ，获取更新后的 DOM。
```



### 11.谈一谈Vue中组件通信？

```
第一种：
	父子通信-父传子：通过在组件上写自定义属性（attribute）实现。父组件可以在子组件身上使用v-bind动态传递prop，数据在子组件内使用props接收。
	父子通信-子传父：通过自定义事件实现。父组件在子组件身上设置 @事件名="方法 |值"，子组件内 调用$emit方法（两个参数，第一个是事件名，第二个是要抛出的值）,就可以触发父组件的方法，父组件通过$event可以访问到被抛出的值
第二种： ref
	ref被用来给元素或组件注册引用信息。引用信息会被注册到父组件的$refs对象上，如果是写在普通的DOM身上，引用指向的就是该DOM元素，如果写在子组件身上，引用就指向组件实例。
	当元素或者组件身上有v-for时，引用的信息是包含DOM节点或组件实例的数组
第三种：provide 和inject
	使用provide可以在祖先组件向所有子孙后代注入一个依赖，provide可以是一个对象或者返回一个对象的函数。
	inject是一个字符串数组或者是一个对象
	二者的绑定不是可响应的
第四种：slot
	使用具名插槽<slot name="123"></slot>，不带name的出口带有隐含的名字"default",在向具名插槽插入内容的时候，可以用<template v-slot="123"></template> 将template元素中的所有内容传入相应的插槽。
此外还有$parent、事件总线、Vuex等。
```



### 12.Vue中逻辑复用技巧有哪些？

```
混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
```



### 13.你项目的鉴权怎么做的？你这个管理系统的权限怎么设计的？

```
是在路由中meta里面，写上包含用户名称的数组，只有在这个数组里面的用户，才有权限访问此路由，定义了一个判断权限的函数，函数循环遍历meta里面的用户名称来匹配当前浏览页面的用户名称，如果匹配到了，就返回true，否则就是false。 使用 router.beforeEach 注册一个全局前置守卫，to是需要设置页面权限的目标，在里面调用判断权限的函数，并拿到函数的返回值，是一个布尔值。如果是true，就放行，如果是false 就返回false。

权限管理⼀般需求是⻚⾯权限和按钮权限的管理.
通过定义全局自定义指令v-permision+路由守卫，路由守卫实现页面权限，v-permison实现按钮权限。
```



### 14.简述Vuex的工作流程？

```
首先通过dispatch去提交一个actions，在actions接收到这个事件后，在actions种进行一些异步或同步操作，根据情况分发给不同的mutations，actions通过commit触发mutations，然后mutations去更新state，在state更新后，就会通知vue进行渲染
```



#### 15. 说说你对 SPA 单⻚⾯的理解，它的优缺点分别是什么？

```
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。⼀旦⻚⾯加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

优点：
1）用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
2）SPA 相对对服务器压力小；
3）前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：
1）首屏（初次）加载慢：为实现单页面 Web 应用功能及显示效果，需要在加载资源的时候将JavaScript、CSS 统一加载，部分页面按需加载；
2）不利于 SEO：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
```



#### 16.v-show 与 v-if 有什么区别？

```
在vue中，v-if和v-show的作用效果是相同的，都能控制元素在页面是否显示

当表达式都为false时，都不会占据页面的位置

当表达式结果为true时，都会占据页面的位置。

区别：
控制手段不同，编译过程不同，编译条件不同
控制手段：v-show隐藏是为元素添加css：display：none，dom元素依旧还在，v-if显示隐藏则是把dom元素整个添加或者删除。
编译过程：v-if切换有一个局部编译写在的过程，切换过程合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。
编译条件：v-if是真正的条件渲染，它会确保在切换的过程条件块的事件监听器和子组件适当地销毁和重建，只有在渲染条件为假时，并不做操作，直到为真才渲染

v-show 有flase变为true时，并不会触发组件的生命周期
v-if由flase变为true的时候，触发组件的beforeCreate，create，beforeMount，mounted钩子，有true变为false时，触发组件的beforeDestory，destoryed方法
性能消耗：v-if有更高的切换消耗，v-show有更高的初始渲染消耗。
```



#### 17. 数组中的哪些⽅法会触发视图的更新？

     push()、pop()、shift()、unshift()、splice()、sort()、reverse()以上这些方法会改变被操作的数组；
    
         filter()、concat()、 slice()  这些方法不会改变被操作的数组，返回一个新的数组；
    
        以上方法都可以触发视图更新。
#### 18. Vue中v-for的key 有什么作⽤？

```
`key` 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。

在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。
如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。也就是说，列表的数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了，就重新渲染，不然就复用之前的元素。

总之，v-for通过key值来提升渲染效率的，在开发中，不直接用index来设置key，而应该设置一个唯一的id来标识数据的唯一性，可以提升渲染的效率。
```



#### 19.computed和method有什么区别？

```
1）computed是响应式地，methods并非响应式的。

2）计算属性有缓存，会把第1次计算的结果放到缓存中，后续重复计算会直接从缓存中拿结果。当计算属性依赖的数据发生了变化，才会重新计算。

而method在每次调用时都要执行。

3）调用方式不一样，computed定义的成员是像属性一样访问，method必须用函数的形式调用，加上（）

4）计算属性中不能写异步代码，当computed有异步操作操作时无效，无法监听数据的变化

5）computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读属性，method不可以
```



#### 20. 什么是双向绑定？v-model的本质是什么？

```
双向绑定：MVVM
View 是视图层，也就是用户界面；
Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控
ViewModel是由指视图数据层。

Vue的双向数据绑定是指model（模型，也就是vue实例中的数据）和view（视图）的双向绑定，即一个发生改变，另一个也会改变。
在MVVM中，是不允许View和Model直接通信的，只能通过ViewModel，而ViewModel主要进行两个事情：
1）观察数据的变化，并对视图层的内容进行更新
2）监听视图层的变化，并能够使对应的数据进行变化

v-model用于 在表单输入元素或组件上创建双向绑定。
本质：
在普通的input框上： v-model 等价于 :value和@input的语法糖
:value实现单向数据绑定,@input实现数据传递并赋值。
在组件上：写v-model等价于 :value和@input的语法糖
:value实现单向数据绑定,@input实现数据向父组件传递，并给父组件的ipt传值
```



#### 21.data选项为什么是⼀个函数⽽不是对象？

```
原因是因为如果data是一个对象的话，两个组件中设置的data都会引用同一个内存地址，而用函数的话，则会在每次引用的时候返回一个新的地址。
组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象
```



#### 22. Vue data 中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏、重新渲染吗？

```
不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。

如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。
```



#### 23. 在 Vue. js开发环境下调⽤API接⼝，如何避免跨域

```
Proxy（代理）
通过启动本地服务器进行代理转发目标服务器。而跨域只针对于浏览器，对于node服务发出的请求是不会出来跨域的，从而解决了跨域的问题。
在vue.config.js中配置:

```

```vue
 server: {
    proxy: {
      "/api": {
        target: "xxx",
        changeOrigin: true
      }
    }
  },
```



#### 24.v-if和v-for⼀起使⽤的弊端及解决办法

```
v-for 的优先级比 v-if 的高，所以每次渲染时都会先循环再进行条件判断，而又因为 v-if 会根据条件为 true 或 false 来决定渲染与否，所以如果将 v-if 和 v-for 一起使用时会特别消耗性能如果有语法检查，则会报语法错误
解决方法：
1、将 v-for 放在外层标签（template），v-if 放在内层标签。
2、使用 computed ，将v-if的判断放在计算属性中执行，再渲染到页面上
```



#### 25. 谈谈你对 keep-alive 的了解？

```
keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们,这样可以防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。
使用onActivated() 和 onDeactivated()可以获取到被包裹的组件是处于什么状态。
 
原理是在 created 函数调用时将需要缓存的 VNode 节点保存在 this.cache 中,在 render（页面渲染） 时，如果 VNode 的 name 符合缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。
```



#### 26. 什么是侦听器？有什么用？

```
有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。

侦听器是用来检测数据变化从而来添加执行自己自定义逻辑的代码（数据一旦发生变化就通知侦听器所绑定方法 ）
```



#### 27. 侦听器能不能监听数组/对象的变化？（可以，但默认不监听深层）deep:true

```
如果侦听的是数组，只能侦听到标准方法修改数组，也就是push pop unshift shift splice sort reverse

如果监听的是对象，那对象的属性值变化时，无法被侦听到，需要使用deep，可以实现深度侦听
```



#### 28. 如何监听一个对象中的某个属性变化？（deep:true, 推荐 'obj.key'这种监听写法）

```
如果监听的是对象，那对象的属性值变化时，无法被侦听到，需要使用deep，可以实现深度侦听

```

```
不能直接侦听响应式对象的属性值，需要用一个返回该属性的 getter 函数
// 提供一个 getter 函数
watch(
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  }
)
```



#### 29. 侦听器为什么默认不支持深度监听？（性能优化）

```
深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。
```



#### 30. 什么是组件化？你怎么理解组件化？

```
组件化就是将一个页面拆分成一个个小的功能模块，每个功能模块完成属于自己这部分独立的功能，使得整个页面的管理和维护变得非常容易。

组件化是Vue中的重要思想
它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。组件树。
组件化思想的应用
1.在项目中充分利用组件化的思想
2.尽可能的将也页面拆分成一个个小的可复用的组件
3.好处：代码更加方便组织和管理，扩展性也更强
```

